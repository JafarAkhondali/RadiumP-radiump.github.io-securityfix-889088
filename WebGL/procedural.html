<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 50%; height: 50% }
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="3js/build/three.min.js"></script>
		<script src="3js/build/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/jquery-1.8.3.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/CanvasRenderer.js"></script>
		<script src="js/stats.min.js"></script>
		<script>
		var WIDTH = 1280, HEIGHT = 800;
		var VIEW_ANGLE = 60, ASPECT = WIDTH/HEIGHT, NEAR = 0.1, FAR = 10000;
		//var canvas=container.getElementsByTagName('canvas');
		var renderer;
		var camera;
		var scene;
		var controls;
		var stats;
		
		
		
		
		init();
		animate();
		
		function init(){
			scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2( 0xcccccc, 0.001 );//This class contains the parameters that define exponential fog, i.e., that grows exponentially denser with the distance.

			light = new THREE.HemisphereLight( 0xfffff0, 0x101020, 1.25 );
			light.position.set( 0.75, 1, 0.25 );
			scene.add( light );

			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(scene.fog.color);//Sets the clear color and opacity.
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(WIDTH,HEIGHT);

			var container = document.getElementById( 'container' );
			container.appendChild(renderer.domElement);

			camera = new THREE.PerspectiveCamera( VIEW_ANGLE,ASPECT,NEAR,FAR);	
			camera.position.z = 200;
			camera.position.y = 50;
			controls = new THREE.OrbitControls(camera,renderer.domElement);
			controls.enableDamping = true;//// If damping is enabled, you must call controls.update() in your animation loop
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;



			


			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild( stats.domElement );


			window.addEventListener( 'resize', onWindowResize, false );

		}


		function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

				requestAnimationFrame( animate );

				controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true

				stats.update();

				render();

		}

			var plane = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshBasicMaterial( { color: 0x101018 } ) );
			plane.rotation.x = - 90 * Math.PI / 180;
			scene.add( plane );
	
			var geometry = new THREE.CubeGeometry(1,1,1);
			geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,0.5,0));//move
			//geometry.faces.splice(3,1);//remove bottom to optimize
			
			//geometry.faceVertexUvs[0].splice( 3, 1 );
			//geometry.faceVertexUvs[0][2][0].set( 0, 0 );
			//geometry.faceVertexUvs[0][2][1].set( 0, 0 );
			//geometry.faceVertexUvs[0][2][2].set( 0, 0 );
			
			//geometry.faceVertexUvs[0][2][3].set( 0, 0 );

			var buildingMesh = new THREE.Mesh(geometry);
			var cityGeometry = new THREE.Geometry();

			var light = new THREE.Color(0xffffff);
			var shadow = new THREE.Color(0x303050);

			for(var i = 0;i<10000;i++)
			{
			buildingMesh.position.x = Math.floor(Math.random()*200-100)*10;
			buildingMesh.position.z = Math.floor(Math.random()*200-100)*10;
			
			buildingMesh.rotation.y = Math.random()*Math.PI*2;

			buildingMesh.scale.x = Math.random()*Math.random()*Math.random()*Math.random()*50 +10;
			buildingMesh.scale.y =  (Math.random() * Math.random() * Math.random() * buildingMesh.scale.x) * 8 + 8;

			buildingMesh.scale.z = buildingMesh.scale.x;

			

			var value = 1 -Math.random()*Math.random();
			var baseColor = new THREE.Color().setRGB(value+Math.random()*0.1,value,value+Math.random()*0.1);
			var topColor = baseColor.clone().multiply(light);
			var bottomColor = baseColor.clone().multiply(shadow);

			var geometry = buildingMesh.geometry;
			for(var j = 0,jl =geometry.faces.length;j<jl;j++){
				if(j===2){
					geometry.faces[j].vertexColors = [baseColor,baseColor,baseColor,baseColor];					
				}
				else {
					geometry.faces[j].vertexColors = [topColor,bottomColor,bottomColor,topColor];
				}
			}
			THREE.GeometryUtils.merge( cityGeometry, buildingMesh );
			//buildingMesh.updateMatrix();
			
			//cityGeometry.merge(buildingMesh.geometry);
		}
			var texture = new THREE.Texture(generateTextureCanvas());
			texture.anisotropy = renderer.getMaxAnisotropy();
			texture.needsUpdate = true;


			var material = new THREE.MeshLambertMaterial({map:texture,vertexColors:THREE.VertexColors});
			var mesh = new THREE.Mesh(cityGeometry,material);
			scene.add(mesh);
		
			function generateTextureCanvas(){
				var canvas = document.createElement('canvas');
				canvas.width = 32;
				canvas.height = 64;
				var context = canvas.getContext('2d');
				context.fillStyle = '#ffffff';
				context.fillRect(0,0,32,64);
				for(var y = 2;y<64;y+=2){
					for(var x=0;x<32;x+=2){
						var value = Math.floor(Math.random()*64);
						context.fillStyle = 'rgb('+[value,value,value].join(',')+')';
						context.fillRect(x,y,2,1);
					}
				}
				var canvas2 = document.createElement('canvas');
				canvas2.width = 512;
				canvas2.height = 1024;
				var context = canvas2.getContext('2d');

				context.imageSmoothingEnabled		= false;
				//context.webkitImageSmoothingEnabled	= false;
				context.mozImageSmoothingEnabled	= false;
				// then draw the image
				context.drawImage( canvas, 0, 0, canvas2.width, canvas2.height );
				// return the just built canvas2
				return canvas2;


			}





		

		
		function render () {	
			renderer.render(scene, camera);
			};

		render();

		</script>
	</body>
</html>